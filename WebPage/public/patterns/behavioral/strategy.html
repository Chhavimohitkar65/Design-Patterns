<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Strategy Pattern - Sorting Visualizer</title>
    <style>
        :root {
            --primary: #3B82F6;
            --secondary: #6366F1;
            --success: #10B981;
            --warning: #F59E0B;
            --danger: #EF4444;
            --light: #F3F4F6;
            --dark: #1F2937;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        body {
            background: var(--light);
            color: var(--dark);
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .pattern-header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .pattern-header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .pattern-definition {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .demo-area {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
        }

        .visualization {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .bars-container {
            height: 300px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 1rem;
            background: var(--light);
            border-radius: 0.5rem;
            margin: 1rem 0;
        }

        .bar {
            flex: 1;
            background: var(--primary);
            transition: height 0.3s ease;
        }

        .bar.comparing {
            background: var(--warning);
        }

        .bar.sorted {
            background: var(--success);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            background: var(--primary);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--secondary);
        }

        .metrics {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .metric-card {
            background: var(--light);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .strategy-selector {
            margin-bottom: 1rem;
        }

        .strategy-selector select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--light);
            border-radius: 0.5rem;
            font-size: 1rem;
            outline: none;
        }

        .strategy-info {
            margin-top: 2rem;
        }

        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .complexity-table th,
        .complexity-table td {
            padding: 0.75rem;
            border: 1px solid var(--light);
            text-align: left;
        }

        .complexity-table th {
            background: var(--light);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="pattern-header">
            <h1>Strategy Design Pattern</h1>
            <p>Defines a family of algorithms, encapsulates each one, and makes them interchangeable.</p>
        </div>

        <div class="pattern-definition">
            <h2>Definition & Purpose</h2>
            <p>The Strategy pattern lets you:</p>
            <ul style="margin-left: 2rem; margin-top: 1rem;">
                <li>Define a family of algorithms</li>
                <li>Encapsulate each algorithm in its own class</li>
                <li>Make the algorithms interchangeable within that family</li>
                <li>Let the algorithm vary independently from clients that use it</li>
            </ul>
        </div>

        <div class="demo-area">
            <div class="visualization">
                <div class="strategy-selector">
                    <select id="algorithmSelect">
                        <option value="bubble">Bubble Sort</option>
                        <option value="selection">Selection Sort</option>
                        <option value="insertion">Insertion Sort</option>
                    </select>
                </div>

                <div id="barsContainer" class="bars-container"></div>

                <div class="controls">
                    <button id="generateBtn" class="btn">Generate New Array</button>
                    <button id="sortBtn" class="btn btn-secondary">Sort</button>
                </div>
            </div>

            <div class="metrics">
                <h3>Algorithm Metrics</h3>
                <div class="metric-card">
                    <div>Comparisons</div>
                    <div id="comparisons" class="metric-value">0</div>
                </div>
                <div class="metric-card">
                    <div>Swaps</div>
                    <div id="swaps" class="metric-value">0</div>
                </div>
                <div class="metric-card">
                    <div>Time Elapsed</div>
                    <div id="timeElapsed" class="metric-value">0ms</div>
                </div>

                <div class="strategy-info">
                    <h3>Complexity Analysis</h3>
                    <table class="complexity-table">
                        <tr>
                            <th>Algorithm</th>
                            <th>Time</th>
                            <th>Space</th>
                        </tr>
                        <tr>
                            <td>Bubble Sort</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Selection Sort</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Insertion Sort</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Strategy Interface
        class SortingStrategy {
            async sort(array, visualCallback) {}
        }

        // Concrete Strategies
        class BubbleSort extends SortingStrategy {
            async sort(array, visualCallback) {
                const n = array.length;
                let swaps = 0;
                let comparisons = 0;

                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        comparisons++;
                        await visualCallback([j, j + 1], 'comparing');
                        
                        if (array[j] > array[j + 1]) {
                            swaps++;
                            [array[j], array[j + 1]] = [array[j + 1], array[j]];
                            await visualCallback([j, j + 1], 'swap');
                        }
                        
                        await visualCallback([j, j + 1], 'normal');
                    }
                    await visualCallback([n - i - 1], 'sorted');
                }

                return { swaps, comparisons };
            }
        }

        class SelectionSort extends SortingStrategy {
            async sort(array, visualCallback) {
                const n = array.length;
                let swaps = 0;
                let comparisons = 0;

                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    
                    for (let j = i + 1; j < n; j++) {
                        comparisons++;
                        await visualCallback([minIdx, j], 'comparing');
                        
                        if (array[j] < array[minIdx]) {
                            minIdx = j;
                        }
                        
                        await visualCallback([minIdx, j], 'normal');
                    }

                    if (minIdx !== i) {
                        swaps++;
                        [array[i], array[minIdx]] = [array[minIdx], array[i]];
                        await visualCallback([i, minIdx], 'swap');
                    }
                    
                    await visualCallback([i], 'sorted');
                }

                return { swaps, comparisons };
            }
        }

        class InsertionSort extends SortingStrategy {
            async sort(array, visualCallback) {
                const n = array.length;
                let swaps = 0;
                let comparisons = 0;

                for (let i = 1; i < n; i++) {
                    let key = array[i];
                    let j = i - 1;
                    
                    while (j >= 0 && array[j] > key) {
                        comparisons++;
                        await visualCallback([j, j + 1], 'comparing');
                        
                        array[j + 1] = array[j];
                        swaps++;
                        await visualCallback([j, j + 1], 'swap');
                        j--;
                    }
                    
                    array[j + 1] = key;
                    await visualCallback([i], 'sorted');
                }

                return { swaps, comparisons };
            }
        }

        // Context
        class Sorter {
            constructor(strategy) {
                this.strategy = strategy;
                this.array = [];
            }

            setStrategy(strategy) {
                this.strategy = strategy;
            }

            generateArray(size = 30) {
                this.array = Array.from(
                    { length: size }, 
                    () => Math.floor(Math.random() * 100) + 1
                );
                return this.array;
            }

            async sort(visualCallback) {
                const startTime = performance.now();
                const metrics = await this.strategy.sort([...this.array], visualCallback);
                const endTime = performance.now();
                
                return {
                    ...metrics,
                    timeElapsed: Math.round(endTime - startTime)
                };
            }
        }

        // UI Controller
        class SortingVisualizer {
            constructor() {
                this.sorter = new Sorter(new BubbleSort());
                this.isRunning = false;
                this.setupEventListeners();
                this.generateNewArray();
            }

            setupEventListeners() {
                document.getElementById('generateBtn').addEventListener('click', 
                    () => this.generateNewArray());
                
                document.getElementById('sortBtn').addEventListener('click', 
                    () => this.startSorting());
                
                document.getElementById('algorithmSelect').addEventListener('change', 
                    (e) => this.changeStrategy(e.target.value));
            }

            changeStrategy(strategyName) {
                const strategies = {
                    bubble: BubbleSort,
                    selection: SelectionSort,
                    insertion: InsertionSort
                };
                
                this.sorter.setStrategy(new strategies[strategyName]());
            }

            generateNewArray() {
                const array = this.sorter.generateArray();
                this.renderBars(array);
                this.resetMetrics();
                document.getElementById('sortBtn').disabled = false;
            }

            async startSorting() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                document.getElementById('sortBtn').disabled = true;
                document.getElementById('generateBtn').disabled = true;
                
                const metrics = await this.sorter.sort((indices, state) => 
                    this.updateVisual(indices, state));
                
                this.updateMetrics(metrics);
                this.isRunning = false;
                document.getElementById('generateBtn').disabled = false;
            }

            renderBars(array) {
                const container = document.getElementById('barsContainer');
                container.innerHTML = array
                    .map(value => `
                        <div class="bar" style="height: ${value * 2}px">
                        </div>
                    `)
                    .join('');
            }

            updateVisual(indices, state) {
                const bars = document.querySelectorAll('.bar');
                const array = this.sorter.array;
                
                // Reset previous states
                bars.forEach(bar => bar.className = 'bar');
                
                // Update heights and states
                indices.forEach(index => {
                    if (index >= 0 && index < bars.length) {
                        bars[index].className = `bar ${state}`;
                        bars[index].style.height = `${array[index] * 2}px`;
                    }
                });

                return new Promise(resolve => setTimeout(resolve, 50));
            }

            resetMetrics() {
                document.getElementById('comparisons').textContent = '0';
                document.getElementById('swaps').textContent = '0';
                document.getElementById('timeElapsed').textContent = '0ms';
            }

            updateMetrics({ comparisons, swaps, timeElapsed }) {
                document.getElementById('comparisons').textContent = comparisons;
                document.getElementById('swaps').textContent = swaps;
                document.getElementById('timeElapsed').textContent = `${timeElapsed}ms`;
            }
        }

        // Initialize the visualizer
        const visualizer = new SortingVisualizer();
    </script>
</body>
</html>